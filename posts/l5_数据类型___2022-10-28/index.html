<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="L5_数据类型___2022-10-28">
<meta itemprop="description" content="* 对应课程: 6.1.1~ 7 目录 基础数据类型 不同之处: sizeof 整数类型 整数的内部表达 负数的表达 二进制负数 补码 数的范围 关键字 unsigned 整数越界 整数的格式化 整数的输入输出"><meta itemprop="datePublished" content="2022-10-28T22:27:47+08:00" />
<meta itemprop="dateModified" content="2022-10-28T22:27:47+08:00" />
<meta itemprop="wordCount" content="4119">
<meta itemprop="keywords" content="C语言学习笔记,study," /><meta property="og:title" content="L5_数据类型___2022-10-28" />
<meta property="og:description" content="* 对应课程: 6.1.1~ 7 目录 基础数据类型 不同之处: sizeof 整数类型 整数的内部表达 负数的表达 二进制负数 补码 数的范围 关键字 unsigned 整数越界 整数的格式化 整数的输入输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhydada.github.io/posts/l5_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B___2022-10-28/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-28T22:27:47+08:00" />
<meta property="article:modified_time" content="2022-10-28T22:27:47+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="L5_数据类型___2022-10-28"/>
<meta name="twitter:description" content="* 对应课程: 6.1.1~ 7 目录 基础数据类型 不同之处: sizeof 整数类型 整数的内部表达 负数的表达 二进制负数 补码 数的范围 关键字 unsigned 整数越界 整数的格式化 整数的输入输出"/>

	<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
	<link rel="manifest" href="../../site.webmanifest">
	<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="../../favicon.ico">

	<title>L5_数据类型___2022-10-28</title>
	<link rel="stylesheet" href="https://zhydada.github.io/css/style.min.037b6ee8f8c1baab6a3d0a9da11c3ff18a7552471f16c59fd98538d5ce99208b.css" integrity="sha256-A3tu6PjBuqtqPQqdoRw/8Yp1UkcfFsWf2YU41c6ZIIs=" crossorigin="anonymous"/>
	<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5f4bfa208c02f20f2e4ca0719d51fac0";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</head>

<body id="page">
	
<header id="site-header" class="animated slideInUp">
    <div class="hdr-wrapper section-inner">
        <div class="hdr-left">
            <div class="site-branding">
                <a href="https://zhydada.github.io">zhyDaDa的个人站点</a>
            </div>
            <nav class="site-nav hide-in-mobile">
                
				<a href="https://zhydada.github.io/posts/">Posts</a>
				<a href="https://zhydada.github.io/tags/">Tags</a>
				<a href="https://zhydada.github.io/about/">About</a>

            </nav>
        </div>
        <div class="hdr-right hdr-icons">
            <span class="hdr-social hide-in-mobile"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=zhydada@qq.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2402128733&amp;site=qq&amp;menue=yes" target="_blank" rel="noopener me" title="Qq"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path transform="scale(0.04) translate(75 40)" stroke-width="50" d="M433.754 420.445c-11.526 1.393-44.86-52.741-44.86-52.741 0 31.345-16.136 72.247-51.051 101.786 16.842 5.192 54.843 19.167 45.803 34.421-7.316 12.343-125.51 7.881-159.632 4.037-34.122 3.844-152.316 8.306-159.632-4.037-9.045-15.25 28.918-29.214 45.783-34.415-34.92-29.539-51.059-70.445-51.059-101.792 0 0-33.334 54.134-44.859 52.741-5.37-.65-12.424-29.644 9.347-99.704 10.261-33.024 21.995-60.478 40.144-105.779C60.683 98.063 108.982.006 224 0c113.737.006 163.156 96.133 160.264 214.963 18.118 45.223 29.912 72.85 40.144 105.778 21.768 70.06 14.716 99.053 9.346 99.704z"></path></svg></a><a href="https://github.com/zhyDaDa" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
        </div>
    </div>
</header>
<div id="mobile-menu" class="animated fast">
    <ul>
        <li><a href="https://zhydada.github.io/posts/">Posts</a></li>
        <li><a href="https://zhydada.github.io/tags/">Tags</a></li>
        <li><a href="https://zhydada.github.io/about/">About</a></li>
    </ul>
</div>

	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Oct 28, 2022</span></div>
				<h1>L5_数据类型___2022-10-28</h1>
			</header>
			<div class="content">
				<p>* 对应课程:  6.1.1~ 7<br>
目录</p>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基础数据类型</a>
<ul>
<li><a href="#%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84">不同之处:</a></li>
<li><a href="#sizeof">sizeof</a></li>
</ul>
</li>
<li><a href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">整数类型</a>
<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E8%BE%BE">整数的内部表达</a>
<ul>
<li><a href="#%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE">负数的表达</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%B4%9F%E6%95%B0">二进制负数</a></li>
<li><a href="#%E8%A1%A5%E7%A0%81">补码</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">数的范围</a>
<ul>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97-unsigned">关键字 unsigned</a></li>
<li><a href="#%E6%95%B4%E6%95%B0%E8%B6%8A%E7%95%8C">整数越界</a></li>
</ul>
</li>
<li><a href="#%E6%95%B4%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96">整数的格式化</a>
<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">整数的输入输出</a></li>
<li><a href="#8%E8%BF%9B%E5%88%B6%E5%92%8C16%E8%BF%9B%E5%88%B6">8进制和16进制</a></li>
</ul>
</li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">选择整数类型</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">浮点类型</a>
<ul>
<li><a href="#%E6%B5%AE%E7%82%B9%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">浮点的输入输出</a>
<ul>
<li><a href="#%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">科学计数法</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6">输出精度</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AE%E7%82%B9%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C%E7%B2%BE%E5%BA%A6">浮点的范围和精度</a>
<ul>
<li><a href="#%E8%B6%85%E8%BF%87%E8%8C%83%E5%9B%B4%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0">超过范围的浮点数</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6">浮点运算的精度</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E8%BE%BE">浮点数的内部表达</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B">选择浮点数类型</a></li>
</ul>
</li>
<li><a href="#%E9%80%BB%E8%BE%91%E7%B1%BB%E5%9E%8B">逻辑类型</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">逻辑运算</a>
<ul>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7">优先级</a></li>
<li><a href="#%E7%9F%AD%E8%B7%AF">短路</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</a></li>
<li><a href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97">逗号运算</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
</ul>
</li>
</ul>
<hr>
<p>C是有类型的语言, 对于其变量, <strong>必须</strong>:</p>
<ul>
<li>在使用前定义</li>
<li>确定类型</li>
</ul>
<p><em>早期语言</em> 以及 <em>面向底层的语言</em> 更强调类型</p>
<ul>
<li>强类型: 有助于发现简单错误</li>
<li>弱类型: 看重事务逻辑</li>
</ul>
<blockquote>
<p><strong>C语言</strong>需要类型, 但是对类型的安全检查并不足够</p>
</blockquote>
<h1 id="基础数据类型">基础数据类型<a href="#基础数据类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>大致分为四个大类(逻辑和整数看做一类)  </p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">包括</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整数</td>
<td style="text-align:center"><code>char</code> <code>short</code> <code>int</code> <code>long</code> <code>long long</code></td>
</tr>
<tr>
<td style="text-align:center">浮点数</td>
<td style="text-align:center"><code>float</code> <code>double</code> <code>long double</code></td>
</tr>
<tr>
<td style="text-align:center">逻辑</td>
<td style="text-align:center"><code>bool</code></td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">自定义</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>前四种被称为 <strong>C语言的基础类型</strong> (即本身就有的)</p>
</blockquote>
<h2 id="不同之处">不同之处:<a href="#不同之处" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<ul>
<li>名称: <code>int</code> <code>long</code> <code>double</code></li>
<li>输入输出时的格式化: <code>%d</code> <code>%ld</code> <code>%lf</code></li>
<li>表达的范围: <code>char</code>&lt;<code>short</code>&lt;<code>int</code>&lt;<code>float</code>&lt;<code>double</code></li>
<li>内存中占据的大小: 1~16字节</li>
<li>内存中的表现形式: 整形是二进制(补码) 浮点数是编码形式(不能直接计算)</li>
</ul>
<h2 id="sizeof">sizeof<a href="#sizeof" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><code>sizeof</code>是一个运算符, 给出某个类型或者变量在内存中占据的 <strong>字节数</strong></p>
<ul>
<li><code>sizeof(int)</code></li>
<li><code>sizeof(i)</code></li>
</ul>
<p><strong>注意</strong>: <code>sizeof</code>是<em>静态的</em>, ta的括号内不会产生实际运算, 其结果<u>在编译时</u>已经<strong>确定下来</strong></p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    int a = 6;
    printf(&#34;sizeof(a)=%ld\n&#34;, sizeof(a));
    printf(&#34;sizeof(a+1.0)=%ld\n&#34;, sizeof(a + 1.0));
    printf(&#34;a=%d&#34;, a);
    return 0;
}
</code></pre><p>其输出结果如下</p>
<pre tabindex="0"><code>sizeof(a)=4
sizeof(a+1.0)=8
a=6
</code></pre><h1 id="整数类型">整数类型<a href="#整数类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>大小比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1字节(8比特)</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center">2字节</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">取决于编译器(CPU), 通常的意义是&quot;1个字&quot;</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">取决于编译器(CPU), 通常的意义是&quot;1个字&quot;</td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">8字节</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>1Byte = 8bit</code></p>
</blockquote>
<p><img src="http://zhyDaDa.github.io/posts/L5_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%A4%BA%E6%84%8F%E5%9B%BE_1.png" alt="">
上图中 <strong>字长</strong> 是说在<em>寄存器和总线</em>中, 一份数据的大小</p>
<h2 id="整数的内部表达">整数的内部表达<a href="#整数的内部表达" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>计算机内部一切都是二进制</p>
<ul>
<li><code>18</code> &ndash;&gt; <code>00010010</code></li>
<li><code>0</code> &ndash;&gt; <code>00000000</code></li>
<li><code>-18</code> &ndash;&gt; ?</li>
</ul>
<blockquote>
<p>一切数据类型的意义在于我们怎么看待ta</p>
</blockquote>
<h3 id="负数的表达">负数的表达<a href="#负数的表达" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>计算机在处理负数时, 会把<code>-</code>视作为一种运算特殊处理, 并不看做<em>负数</em></p>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">实际运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12+(-18)</td>
<td style="text-align:center">12-18</td>
</tr>
<tr>
<td style="text-align:center">12-(-18)</td>
<td style="text-align:center">12+18</td>
</tr>
<tr>
<td style="text-align:center">12*(-18)</td>
<td style="text-align:center">-(12*18)</td>
</tr>
</tbody>
</table>
<h3 id="二进制负数">二进制负数<a href="#二进制负数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>有三种方案:</p>
<ul>
<li>仿照十进制, 取一个特殊标记表示负数</li>
<li>取中间数为0, 如<code>10000000</code>为<code>0</code>, 比ta小就是负数</li>
<li><strong>补码</strong></li>
</ul>
<blockquote>
<p>第一种方案在计算时不能按照常规二进制计算, 要求特殊处理, 太复杂<br>
二方案每次在获取数据的时候总要减去<code>10000000</code>, 也很复杂</p>
</blockquote>
<h3 id="补码">补码<a href="#补码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>考虑<code>-1</code>, 希望能实现<code>-1 + 1 = 0</code></p>
<ul>
<li><code>0</code> &ndash;&gt;<code>00000000</code></li>
<li><code>1</code> &ndash;&gt;<code>00000001</code></li>
<li><code>-1</code>&ndash;&gt;<code>11111111</code></li>
</ul>
<blockquote>
<p>这里<code>-1 + 1</code>的结果实际上是<code>1 00000000</code><br>
但由于表示数字的字节仅仅<em><strong>8bit</strong></em>, 所以多出来的那位被舍去, 成了<code>0</code></p>
</blockquote>
<p><code>11111111</code>被当做<strong>纯二进制</strong>看待时, 是<code>255</code><br>
但被当做<strong>补码</strong>看待时, 是<code>-1</code></p>
<p>同理, 对于<code>-a</code>, 补码就是<code>0-a</code><br>
实际上是 $2^n-a$, 其中<code>n</code>是这种类型的位数</p>
<blockquote>
<p><strong>补码的意义</strong>就是拿<em>补码和原码</em>可以加出一个溢出的<em>零</em><br>
回到之前的三种方案, 补码的优势在于<strong>不用变化符号</strong>, 直接做加法就可以得出结果</p>
</blockquote>
<h2 id="数的范围">数的范围<a href="#数的范围" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>对于一个字节(8位 即一个<em><strong>char</strong></em>), 可以表达的是:</p>
<ul>
<li><code>00000000-11111111</code></li>
</ul>
<p>其中:</p>
<table>
<thead>
<tr>
<th style="text-align:center">内存表示</th>
<th style="text-align:center">纯二进制角度</th>
<th style="text-align:center">整数角度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>00000000</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center"><code>11111111</code> ~ <code>10000000</code></td>
<td style="text-align:center">255 ~ 128</td>
<td style="text-align:center">-1 ~ -128</td>
</tr>
<tr>
<td style="text-align:center"><code>00000001</code> ~ <code>01111111</code></td>
<td style="text-align:center">1 ~ 127</td>
<td style="text-align:center">1 ~ 127</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>: 这里所说的&quot;整数角度&quot;是针对<em><strong>char</strong></em>来说的<br>
不同类型有不同的角度, 下面就是个例子</p>
</blockquote>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    char c = 255;
    int i = 255;
    printf(&#34;c=%d; i=%d&#34;, c, i);
    return 0;
}
</code></pre><p>其结果为:</p>
<pre tabindex="0"><code>c=-1; i=255
</code></pre><p>分析如下:</p>
<ul>
<li>对于<em><strong>char</strong></em>来说,
<ul>
<li>大小是 <strong>8bit</strong></li>
<li>在内存中表现为 <code>11111111</code></li>
<li>解读为补码(因为首位为<code>1</code>)</li>
<li>输出为<code>-1</code></li>
</ul>
</li>
<li>对于<em><strong>int</strong></em>来说,
<ul>
<li>大小是 <strong>4Byte</strong></li>
<li>在内存中表现为 <code>00000000 00000000 00000000 11111111</code></li>
<li>解读为正整数</li>
<li>输出为<code>255</code></li>
</ul>
</li>
</ul>
<h3 id="关键字-unsigned">关键字 unsigned<a href="#关键字-unsigned" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在定义变量的时候在类型前面添上 <strong>关键字</strong><code>unsigned</code></p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    unsigned char c = 255;
    printf(&#34;c=%d&#34;, c);
    return 0;
}
</code></pre><p>运行结果:<br>
<code>c=255</code></p>
<p>如果一个字面量常数要想表达自己是<code>unsigned</code>, 在其后面加上<code>u</code>或<code>U</code></p>
<ul>
<li>例如 <code>255U</code></li>
</ul>
<blockquote>
<p><code>unsigned</code>的含义是说: 该数被视作一个正数, 不会被视作补码
其<strong>副作用</strong>就是将一个整数能表示的正数部分扩大两倍<br>
但同样地, ta就无法表示负数</p>
<blockquote>
<p>但是, <em><strong>unsigned</strong></em><strong>关键字</strong>设计的初衷并不是为了扩大正数部分<br>
而是为了做纯二进制计算, 主要是为了移位</p>
</blockquote>
</blockquote>
<h3 id="整数越界">整数越界<a href="#整数越界" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>如果不断的做<code>+1</code>运算, 到了范围的边界时<br>
考虑到之前的理论, 正整数将&quot;绕一圈&quot;变为负数<br>
用程序来说明:</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    char c = 128;
    c = c + 1;
    printf(&#34;c+1=%d\n&#34;, c);
    unsigned char u = 0;
    u = u - 1;
    printf(&#34;u-1=%d&#34;, u);
    return 0;
}
</code></pre><p>其结果是:</p>
<pre tabindex="0"><code>c+1=-127
u-1=255
</code></pre><h2 id="整数的格式化">整数的格式化<a href="#整数的格式化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="整数的输入输出">整数的输入输出<a href="#整数的输入输出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>只有两种形式: <code>int</code> 或 <code>long long</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">格式</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center"><code>int</code> <code>char</code> <code>short</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%u</code></td>
<td style="text-align:center"><code>unsigned</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%ld</code></td>
<td style="text-align:center"><code>long long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%lu</code></td>
<td style="text-align:center"><code>unsigned long long</code></td>
</tr>
</tbody>
</table>
<p>可以通过以下代码理解 &ldquo;数据类型重在如何看待ta&rdquo;</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    char c = -1;
    int i = -1;
    printf(&#34;c=%u, i=%u\n&#34;, c, i);
    return 0;
}
</code></pre><p>其结果为:</p>
<pre tabindex="0"><code>c=4294967295, i=4294967295
</code></pre><blockquote>
<p><code>printf</code>在接收数据时, 会把<br>
<strong>小于等于</strong><code>int</code>大小的整数类型转化为<code>int</code>传入<br>
<strong>大于</strong><code>int</code>大小的整数类型转化为<code>long</code>传入</p>
</blockquote>
<blockquote>
<p>在计算机内存的数据是<strong>同样的</strong>, 但以<strong>不同的方式</strong>看待就会有不同的结果<br>
这和计算机内部数据是什么无关, 而取决于是否以<strong>正确的方式</strong>来使用数据, 使之成为人能读懂的表示</p>
</blockquote>
<h3 id="8进制和16进制">8进制和16进制<a href="#8进制和16进制" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>字面量</strong>整数前加<code>0</code>表示 <strong>八进制</strong><br>
加<code>0x</code>表示 <strong>十六进制</strong></p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    char c = 012;
    int i = 0x12;
    printf(&#34;c=%d, i=%d\n&#34;, c, i);
    return 0;
}
</code></pre><p>其结果为:</p>
<pre tabindex="0"><code>c=10, i=18
</code></pre><blockquote>
<p>同样的, 这里的进制只是我们的视角<br>
编译器仍旧会换算为二进制</p>
<blockquote>
<p><strong>进制</strong>只是表示如何把数字表达为字符串<br>
这与内部如何表达数字无关</p>
</blockquote>
</blockquote>
<p>要想输入输出:</p>
<ul>
<li><strong>八进制</strong>的格式为 <code>%o</code></li>
<li><strong>十六进制</strong>的格式为 <code>%x</code></li>
</ul>
<blockquote>
<p><strong>注意</strong>: 在十六进制中,<br>
<code>%x</code>会输出带有小写字母的十六进制数字<br>
<code>%X</code>会输出带有大写字母的十六进制数字</p>
</blockquote>
<p><strong>16进制</strong>很适合表达2进制数据<br>
因为<strong>4位二进制</strong>刚好是一个<strong>16进制位</strong><br>
而<strong>8进制</strong>的一位数字正好表达<strong>3位二进制</strong></p>
<blockquote>
<p>因此早期计算机的字长是<code>12</code>的倍数, 而非8</p>
</blockquote>
<h2 id="选择整数类型">选择整数类型<a href="#选择整数类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>为什么那么多类型?</p>
<ul>
<li>为了直接和硬件打交道(16位的类型控制芯片上的16个引脚)</li>
<li>早期语言的风格</li>
</ul>
<p><strong>建议</strong>: 没有特殊需要, 就选<em><strong>int</strong></em></p>
<ul>
<li>如今计算机CPU的字长普遍是32/64bit, 一次内存的读写正好是一个<em><strong>int</strong></em>的大小, 一次计算也是一个<em><strong>int</strong></em></li>
<li>选择更短的类型不会更快, 甚至可能更慢</li>
<li>考虑到现代编译器一般会设计 <em>内存对齐</em>, 所以更短的类型在内存中可能实际占据的也是一个<em><strong>int</strong></em>的大小<br>
(即便 <em><strong>sizeof</strong></em> 告诉你更小)</li>
</ul>
<p><em><strong>unsigned</strong></em>与否只影响输出的结果, 内部计算是<strong>一样的</strong></p>
<h1 id="浮点类型">浮点类型<a href="#浮点类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字长</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">有效数字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">32</td>
<td style="text-align:center">$\pm(1.20\times10^{-38} \sim 3.4\times10^{38})$<br>以及$0,\pm \inf,nan$</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">64</td>
<td style="text-align:center">$\pm(2.2\times10^{-308} \sim 1.79\times10^{308})$<br>以及$0,\pm \inf,nan$</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<h2 id="浮点的输入输出">浮点的输入输出<a href="#浮点的输入输出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center"><code>scanf</code></th>
<th style="text-align:center"><code>printf</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>%f</code></td>
<td style="text-align:center"><code>%f, %e</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>%lf</code></td>
<td style="text-align:center"><code>%f, %e</code></td>
</tr>
</tbody>
</table>
<p>其中<code>%e</code>是用科学计数法输出</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    double ff = 1234.56789;
    printf(&#34;%e, %f, %E&#34;, ff, ff, ff);
    return 0;
}
</code></pre><p>其输出结果为:</p>
<pre tabindex="0"><code>1.234568e+003, 1234.567890, 1.234568E+003
</code></pre><h3 id="科学计数法">科学计数法<a href="#科学计数法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>以 <code>-5.67E+16</code> 为例子</p>
<ul>
<li>最前面可选的<code>+</code>或<code>-</code>符号</li>
<li>小数点<code>.</code>也是可选的</li>
<li>可以用<code>e</code>或<code>E</code></li>
<li>符号可以是<code>+</code>或<code>-</code>也可以省略(表示<code>+</code>)</li>
<li>整个词不能有空格</li>
</ul>
<h3 id="输出精度">输出精度<a href="#输出精度" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在<code>%</code>和<code>f</code>之间加上<code>.n</code>可以指定输出小数点后的<code>n</code>位(做四舍五入)</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    printf(&#34;%.3f\n&#34;, -0.0049);
    printf(&#34;%.30f\n&#34;, -0.0049);
    printf(&#34;%.3f\n&#34;, -0.00049);
    return 0;
}
</code></pre><p>其结果为:</p>
<pre tabindex="0"><code>-0.005
-0.004899999999999999800000000000
-0.000
</code></pre><h2 id="浮点的范围和精度">浮点的范围和精度<a href="#浮点的范围和精度" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="超过范围的浮点数">超过范围的浮点数<a href="#超过范围的浮点数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li><em><strong>inf</strong></em>表示无穷大(即超出范围的浮点数)</li>
<li><em><strong>nan</strong></em>表示不存在的浮点数</li>
</ul>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
int main()
{
    printf(&#34;%f\n&#34;, 12.0 / 0.0);
    printf(&#34;%f\n&#34;, -12.0 / 0.0);
    printf(&#34;%f\n&#34;, 0.0 / 0.0);
    return 0;
}
</code></pre><p>其输出结果为:</p>
<pre tabindex="0"><code>inf
-inf
nan
</code></pre><p>也可以是:</p>
<pre tabindex="0"><code>1.#INF00
-1.#INF00
-1.#IND00
</code></pre><blockquote>
<p>考虑到现在讨论的范畴是浮点数<br>
如果用整数输出<code>12/0</code>会发生<em>编译错误</em><br>
这是因为<em><strong>nan/±inf</strong></em>为浮点数独有</p>
</blockquote>
<h3 id="浮点运算的精度">浮点运算的精度<a href="#浮点运算的精度" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><strong>注意</strong>: 浮点运算是<strong>没有精度</strong>的</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
void main()
{
    float a, b, c;
    a = 1.345f;
    b = 1.123f;
    c = a + b;
    if (c == 2.468)
        printf(&#34;相等\n&#34;);
    else
        printf(&#34;不相等! c=%.10f, 或%f\n&#34;, c, c);
}
</code></pre><p>其输出结果为:</p>
<pre tabindex="0"><code>不相等! c=2.4679999352, 或2.468000
</code></pre><blockquote>
<p>输出的结果中, 前者才是<code>c</code>真正的数值, 后者已经由于浮点数的7位有效数字做了四舍五入处理</p>
</blockquote>
<p><strong>注意</strong>:</p>
<ul>
<li>带小数点的字面量是<em><strong>double</strong></em> 而非 <em><strong>float</strong></em></li>
<li><em><strong>float</strong></em> 需要用<code>f</code>或<code>F</code>后缀来表明身份</li>
<li>在<strong>浮点计算</strong>中, <code>f1==f2</code>这类的关系判断可能失败</li>
<li>如果迫不得已, 可以通过<code>fabs(f1-f2)&lt;1e-12</code>来代替</li>
<li>其实一般<code>1e-10</code>就可以了</li>
<li>不能用浮点数来计算<strong>金额</strong>, 因为其误差会累积起来</li>
<li>只能在一定的范围内相信浮点数的计算结果, 其误差很大</li>
</ul>
<h2 id="浮点数的内部表达">浮点数的内部表达<a href="#浮点数的内部表达" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>浮点数在内存中以编码形式储存</p>
<ul>
<li><strong>1bit</strong> 用与判断正负号</li>
<li><strong>11bit</strong> 用于记录指数部分</li>
<li><strong>52bit</strong> 用于记录分数部分</li>
</ul>
<blockquote>
<p>事实上实际用不了这么多位</p>
</blockquote>
<p>浮点数在计算时是由专门的硬件部件实现的<br>
计算 <em><strong>double</strong></em>和<em><strong>float</strong></em>要用的硬件部件是一样的</p>
<h2 id="选择浮点数类型">选择浮点数类型<a href="#选择浮点数类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>如果没有特殊需要, 只使用 <em><strong>double</strong></em></p>
<blockquote>
<p>现代CPU能够直接对<em><strong>double</strong></em>做硬件运算<br>
计算速度和存储速度都不比<em><strong>float</strong></em>慢</p>
</blockquote>
<h1 id="逻辑类型">逻辑类型<a href="#逻辑类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>C语言原先是<strong>没有</strong>布尔类型的, 用<code>0</code>和<code>非0</code>就可以判断<br>
后来引入了<em>布尔类型</em>, 由于其不是<em>原生类型</em>, 因此使用前要先加上<code>#include &lt;stdbool.h&gt;</code><br>
之后才能使用<em><strong>bool</strong></em>和<em><strong>true/false</strong></em><br>
但事实上, 在输入输出时, 布尔类型仍旧当做整数使用, 无法输出为<em><strong>true/false</strong></em></p>
<h2 id="逻辑运算">逻辑运算<a href="#逻辑运算" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><code>||</code></td>
<td style="text-align:center">逻辑或</td>
</tr>
</tbody>
</table>
<blockquote>
<p>数学中的<code>4&lt;x&lt;6</code>在程序中, 应当表示为<code>x&gt;4&amp;&amp;x&lt;6</code></p>
</blockquote>
<p>考虑这样一个例子:<br>
<code>!age &lt; 20</code></p>
<blockquote>
<p>由于逻辑非优先级最高, <code>!age</code>被结合在一起, 其结果仅可能是<code>0</code>或<code>1</code>, 那么整个表达式的结果永远为<code>1</code></p>
</blockquote>
<h3 id="优先级">优先级<a href="#优先级" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>()</code></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>! ++ --</code>和单目的<code>+ -</code></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>* / %</code></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>+ -</code></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>&lt; &lt;= &gt; &gt;=</code></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><code>== !=</code></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><code>&amp;&amp;</code></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><code>||</code></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><code>a?b:c</code></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">所有的赋值运算符</td>
</tr>
</tbody>
</table>
<h3 id="短路">短路<a href="#短路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>逻辑运算是<strong>自左向右</strong>进行的, 若左侧的结果已经可以决定结果, 就<strong>不会执行</strong>右侧的计算</p>
<ul>
<li>对于<code>&amp;&amp;</code>, 左侧有<code>false</code>不做右侧</li>
<li>对于<code>||</code>, 左侧有<code>true</code>不做右侧</li>
</ul>
<h3 id="条件运算符">条件运算符<a href="#条件运算符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><code>ans = a ? b : c</code>等价于</p>
<pre tabindex="0"><code>if(a){
  ans = b;
}else{
  ans = c;
}
</code></pre><p>这种写法看似简洁, 但当嵌套起来就会出现麻烦<br>
<strong>注意</strong>: 条件运算符是自右向左结合的<br>
<code>w&lt;x ? x+w : x&lt;y ? x:y</code></p>
<blockquote>
<p>尽量不要使用嵌套的条件表达式!!!</p>
</blockquote>
<h3 id="逗号运算">逗号运算<a href="#逗号运算" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>逗号是一个<strong>运算符</strong>, 用来连接两个表达式, 并以右侧表达式的值作为其结果<br>
逗号的优先级是所有运算符中最低的, 所以其两侧的表达式会先计算<br>
逗号的组合关系是自左向右, 左侧先算, 右侧后算, 取右侧的结果作为整体的结果<br>
主要用途是<em><strong>for</strong></em><br>
<code>for(i=0,j=10; i&lt;j; i++,j--)</code></p>
<h1 id="类型转换">类型转换<a href="#类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>
<p>当运算符两边出现不一致的类型时, 会自动转换成较宽/大的类型<br>
<em>宽/大</em>是指能表达的<strong>数的范围</strong>更大</p>
<h2 id="自动类型转换">自动类型转换<a href="#自动类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><strong>整数</strong>: char → short → int → long → long long<br>
<strong>浮点</strong>: int → float → double</p>
<p>对于<code>printf</code>, 任何小于<em><strong>int</strong></em>的类型都会被转化成<em><strong>int</strong></em><br>
<em><strong>float</strong></em>会被转化成<em><strong>double</strong></em><br>
<strong>但是</strong>, <code>scanf</code>不会</p>
<ul>
<li>要输入<code>short</code>, 需要使用<code>%hd</code></li>
<li>要输入<code>long</code>, 需要使用<code>%ld</code></li>
<li>若要以整数的形式输入<code>char</code>, 必须先得到整数再交给<code>char</code></li>
</ul>
<h2 id="强制类型转换">强制类型转换<a href="#强制类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>要把一个量强制转换成另一个类型(通常是较小的类型), 需要采用<code>(类型)值</code>的写法, 例如:</p>
<ul>
<li><code>(int)10.2</code></li>
<li><code>(short)32</code></li>
</ul>
<p><strong>注意</strong>:</p>
<ul>
<li>要留意<em>安全性</em>, 即大的数<strong>不一定能</strong>转换为小的数<br>
或者说, 小的变量<strong>不总能</strong>表达大的量</li>
<li>这种转换只是计算出了一个新的量, 并<strong>不会改变</strong>原来的量的值或者类型</li>
<li>强制类型转换的优先级<strong>高于</strong>四则运算</li>
</ul>
<pre tabindex="0"><code>double a = 1.0;
double b = 2.0;
int i = (int)b / a;
</code></pre><blockquote>
<p>上述的例子中, 先处理<code>(int)b</code>得到<code>2</code>, 再与浮点数<code>a</code>运算得到了浮点数的结果, 显然类型不一致, 会报错</p>
</blockquote>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://zhydada.github.io/tags/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">C语言学习笔记</a></span><span class="tag"><a href="https://zhydada.github.io/tags/study">study</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>4119 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2022-10-28 22:27 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://zhydada.github.io/posts/l6_%E5%87%BD%E6%95%B0___2022-11-07/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>L6_函数___2022-11-07</span>
			</a>
			<a class="prev-post" href="https://zhydada.github.io/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>自定义油猴脚本</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2023 <a href="https://zhydada.github.io">zhyDaDa</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://zhydada.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://zhydada.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	

</body>

</html>
